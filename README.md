# React-Not-CRA
> 프론트엔드 공부를 하면서 CRA, vue-cli 등 도구만을 사용해왔다. 개발자가 되어서 내가 쓰는 도구가 어떻게 동작하는지, 뭐가 사용되는지 모르는 것은 옳지 못하다고 생각했다.   
CRA를 사용한 프로젝트 세팅이 아닌 처음부터 직접 세팅해보며 프론트엔드 프로젝트 구조를 이해하고 CRA를 이해합시다.   
공부에 사용된 사이트 : [김정환님 연재물](https://jeonghwan-kim.github.io/series/2019/12/09/frontend-dev-env-npm.html)

# Node, NPM
## node
당연히 가장 먼서 세팅해야하는 것은 node와 npm이다. 지금은 너무나도 자연스럽게 `npm init -y`를 먼저 사용한 세팅을 진행하지만, 문득 **왜 사용할까?**라는 생각이 들곤 했다. 
### 왜 필요해?
가장 먼저 나타난 이유는 **최신 스펙의 개발**이다. javascript는 발전 속도가 너무나도 빠르다. 하지만, 브라우저는 이 속도를 따라오지 못한다. 이 둘 사이의 차이를 이어주는 징검다리 역할을 해주는 것이 node이다. node 환경에서 개발된 바벨, 웹팩 등의 환경을 통해 브라우저와 자바스크립트를 이어줄 수 있다.   
### 빌드, 배포
연합뉴스 선배와 얘기했을 때(2019년에..) 불과 3~4년 전만 해도 복사 붙여넣기를 통해 빌드,배포를 진행하였다고 한다. node는 이런 과정을 자동화를 시켜주고 테스트, 라이브러리 의존성도 해결해준다.
### 커스터마이징
개발 환경 셋팅을 도와주는 것들은 여러가지가 있다. CRA(create-react-app), vue-cli가 대표적으로 사용된다. 당연히 편리하지만, 그대로 사용할 수 없는 경우도 있을 것이다. 이전에 카프카 consumer 세팅을 하려하는 데에도 애를 먹었던 적이 있다(결국 해결하진 못했지만).

## npm
npm는 Node Package Manage로 node환경 속 패키지 관리나 빌드 등 프로젝트 관리하는 툴이다.
### init
우선 초기화를 해주자. 즉, 프로젝트를 생성하는 것이다. `npm init`을 입력하면 여러가지 정보를 기입하라고 나타난다. 쓰기 귀찮으면 `-y`조건을 넣어주자! 입력하는 정보는 아래와 같다.
```
name        : 프로젝트 이름
version     : 버전
description : 설명
main        : 노드 어플리케이션인 경우 진입점 경로(default : index.js), 프론트엔드 프로젝트에선 사용하지 않는다.
scripts     : 프로젝트에서 사용되는 명령어
author      : 작성자
license     : 라이센스
```
### scripts
npm을 사용한다면 스크립트를 가장 많이 사용할 것이다. 대표적으로 start, install, uninstall, test가 존재한다. 그 외에도 매우매우 많지만 대표적인 것만 알아두자!   
명령어는 추가도 가능하다. 대신 새롭게 추가한 것은 `npm run ${추가한 이름}`으로 진행해야 한다.
```
"scripts":{
  "start": "echo \"start\"",
  "build" : "echo \"build\"",
}
```

# Webpack
## Before Module
모듈이 사용되기 전, 하나의 HTML에서 로딩 후 사용되었다. 하지만, 사용하고자 하는 함수가 전역 공간에 노출되기 때문에 다른 파일의 같은 이름을 사용한다면 충돌이 발생할 수 있다.
```
//index.html
<script src="math.js/>
<script src="sum.js/>
<script src="app.js/>

//math.js
function sum(a,b){ return a+b; }
//sum.js
function sum(a,b){ return a+b+a+b;}
//app.js
sum(1,2);
```
### IIFE
이를 방지하기 위해 즉시표현식을 사용한다. 
```
var math = {};
(function(){
  function sum(a,b){ return a+b; }
  math.sum = sum;
})();
```
우리는 math 객체의 sum함수로써 사용할 수 있지만 sum이란 함수는 스코프에 감추어졌기 때문에 접근할 수 없다.
## Module
모듈을 통해 다른 자바스크립트 파일의 함수를 가져올 수 있게 되었다. 최근엔 ES2015에서 나온 표준 모듈 시스템인 export/import를 사용하게 된다. 하지만 이도 지원하지 않는 부라우저가 있다..
```
//math.js
export function sum(a,b){return a+b;}
//app.js
import {sum} from './math.js';
console.log(sum(1,2));
```
## Webpack
[웹팩](https://webpack.js.org/)은 여러개 파일을 하나로 합쳐주는 번들러이다. 하나의 시작점으로부터 의존성을 가지는 모듈을 찾아내어 합쳐버리는 것이다. 웹팩을 사용해보자! 다운로드를 받았으면 `npx webpack --help` 명령어를 통해 옵션들을 살펴보자.
```
npm install -D webpack webpack-cli

npx webpack --help
--entry <value...>                     The entry point(s) of your application e.g. ./src/main.js.
--mode <value>                         Defines the mode to pass to webpack.
-o, --output-path <value>              Output location of the file generated by webpack e.g. ./dist/.
-c, --config <value...>                Provide path to a webpack configuration file e.g. ./webpack.config.js.
```
이것들 외에 다른 옵션들도 많지만 기본적으로 중요한 것들을 뽑아보았다. 설명을 보면 알겠지만 각각 아래와 같다.   
* entry : 시작이 되는 자바스크립트 코드   
* mode : development, production인지, 이에 따른 플러그인 사용이 있음.   
* output : 번들파일 경로   
* config : webpack 설정 파일 이름   
webpack config file의 경우 프로젝트에 webpack.config.js란 이름으로 생성해두면 특별한 옵션없이 사용 가능하다. 만약, mode에 따라서나 상황에 따른 설정이 많다면 사용하자!   
entry, mode, output을 설정 파일로 만들면 아래와 같다.
### webpack config file
```
const path=require('path');
module.exports={
  mode:'development',
  entry:{
    main:'./src/app.js'
  },
  output:{
    filename:'bundle.js',
    path:path.resolve("./dist")
  }
}
```
프로젝트를 설정하고 npx webpack을 입력하면 `dist/main.js`가 생기는걸 볼 수 있다. 물론 이는 package.json에 설정하고 사용할 수 있다.
```
"scripts": {
    "build": "npx webpack",   //script를 만들자!
    "test": "echo \"Error: no test specified\" && exit 1"
  }
```
## Loader
웹팩은 모든 파일을 모듈로 취급한다. 자바스크립트 모듈 뿐만 아니라 css, image font 등등 모두 모듈로 보기 떄문에 import를 사용한다면 코드 안으로 가져올 수 있다.    
이런게 가능한 이유는 **로더** 덕분이다. 로더는 타입스크립트를 자바스크립트로 변환해주거나 이미지를 URL로 바꿔주는 등등 여러 역할을 해준다. 자주 쓰이는 로더들도 있지만 그것들을 보기 전에 직접 로더를 만들어보면서 어떻게 동작하는지 알아보자!   
```
//src/loader/myloader.js
module.exports = function myloader(content){
  console.log(content);
  console.log('loader hi');
  return content;
}

/*
import {sum} from './math';
const a = sum(1,2);
console.log(a);
loader hi
export function sum(a,b) {
  return a+b;
}
loader hi
*/

//webpack.config.js
...
module:{
  rules:[
    {
      test:/\.js$/,
      use:[path.resolve('./src/loader/myloader.js)]
    }
  ]
}
```
로더는 content를 인자로 받는 함수이며 이를 통한 또 다른 문자열을 내보낸다. content의 내용을 보니 entry부터 시작해서 import된 것들의 코드 문자열이란 것을 알 수 있다!   
그렇다면 console.log를 alert로 바꿔서 번들링하는 로더를 만들어보자!
```
module.exports = function myloader(content){
  return content.replace('console.log(','alert(');
}
```
`dist/main.js`를 html에 import해보면 alert가 되는 것을 알 수 있다.
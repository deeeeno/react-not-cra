# React-Not-CRA
> 프론트엔드 공부를 하면서 CRA, vue-cli 등 도구만을 사용해왔다. 개발자가 되어서 내가 쓰는 도구가 어떻게 동작하는지, 뭐가 사용되는지 모르는 것은 옳지 못하다고 생각했다.   
CRA를 사용한 프로젝트 세팅이 아닌 처음부터 직접 세팅해보며 프론트엔드 프로젝트 구조를 이해하고 CRA를 이해합시다.   
공부에 사용된 사이트 : [김정환님 연재물](https://jeonghwan-kim.github.io/series/2019/12/09/frontend-dev-env-npm.html)

# Node, NPM
## node
당연히 가장 먼서 세팅해야하는 것은 node와 npm이다. 지금은 너무나도 자연스럽게 `npm init -y`를 먼저 사용한 세팅을 진행하지만, 문득 **왜 사용할까?**라는 생각이 들곤 했다. 
### 왜 필요해?
가장 먼저 나타난 이유는 **최신 스펙의 개발**이다. javascript는 발전 속도가 너무나도 빠르다. 하지만, 브라우저는 이 속도를 따라오지 못한다. 이 둘 사이의 차이를 이어주는 징검다리 역할을 해주는 것이 node이다. node 환경에서 개발된 바벨, 웹팩 등의 환경을 통해 브라우저와 자바스크립트를 이어줄 수 있다.   
### 빌드, 배포
연합뉴스 선배와 얘기했을 때(2019년에..) 불과 3~4년 전만 해도 복사 붙여넣기를 통해 빌드,배포를 진행하였다고 한다. node는 이런 과정을 자동화를 시켜주고 테스트, 라이브러리 의존성도 해결해준다.
### 커스터마이징
개발 환경 셋팅을 도와주는 것들은 여러가지가 있다. CRA(create-react-app), vue-cli가 대표적으로 사용된다. 당연히 편리하지만, 그대로 사용할 수 없는 경우도 있을 것이다. 이전에 카프카 consumer 세팅을 하려하는 데에도 애를 먹었던 적이 있다(결국 해결하진 못했지만).

## npm
npm는 Node Package Manage로 node환경 속 패키지 관리나 빌드 등 프로젝트 관리하는 툴이다.
### init
우선 초기화를 해주자. 즉, 프로젝트를 생성하는 것이다. `npm init`을 입력하면 여러가지 정보를 기입하라고 나타난다. 쓰기 귀찮으면 `-y`조건을 넣어주자! 입력하는 정보는 아래와 같다.
```
name        : 프로젝트 이름
version     : 버전
description : 설명
main        : 노드 어플리케이션인 경우 진입점 경로(default : index.js), 프론트엔드 프로젝트에선 사용하지 않는다.
scripts     : 프로젝트에서 사용되는 명령어
author      : 작성자
license     : 라이센스
```
### scripts
npm을 사용한다면 스크립트를 가장 많이 사용할 것이다. 대표적으로 start, install, uninstall, test가 존재한다. 그 외에도 매우매우 많지만 대표적인 것만 알아두자!   
명령어는 추가도 가능하다. 대신 새롭게 추가한 것은 `npm run ${추가한 이름}`으로 진행해야 한다.
```
"scripts":{
  "start": "echo \"start\"",
  "build" : "echo \"build\"",
}
```

# Webpack
## Before Module
모듈이 사용되기 전, 하나의 HTML에서 로딩 후 사용되었다. 하지만, 사용하고자 하는 함수가 전역 공간에 노출되기 때문에 다른 파일의 같은 이름을 사용한다면 충돌이 발생할 수 있다.
```
//index.html
<script src="math.js/>
<script src="sum.js/>
<script src="app.js/>

//math.js
function sum(a,b){ return a+b; }
//sum.js
function sum(a,b){ return a+b+a+b;}
//app.js
sum(1,2);
```
### IIFE
이를 방지하기 위해 즉시표현식을 사용한다. 
```
var math = {};
(function(){
  function sum(a,b){ return a+b; }
  math.sum = sum;
})();
```
우리는 math 객체의 sum함수로써 사용할 수 있지만 sum이란 함수는 스코프에 감추어졌기 때문에 접근할 수 없다.
## Module
모듈을 통해 다른 자바스크립트 파일의 함수를 가져올 수 있게 되었다. 최근엔 ES2015에서 나온 표준 모듈 시스템인 export/import를 사용하게 된다. 하지만 이도 지원하지 않는 부라우저가 있다..
```
//math.js
export function sum(a,b){return a+b;}
//app.js
import {sum} from './math.js';
console.log(sum(1,2));
```
## Webpack
[웹팩](https://webpack.js.org/)은 여러개 파일을 하나로 합쳐주는 번들러이다. 하나의 시작점으로부터 의존성을 가지는 모듈을 찾아내어 합쳐버리는 것이다. 웹팩을 사용해보자! 다운로드를 받았으면 `npx webpack --help` 명령어를 통해 옵션들을 살펴보자.
```
npm install -D webpack webpack-cli

npx webpack --help
--entry <value...>                     The entry point(s) of your application e.g. ./src/main.js.
--mode <value>                         Defines the mode to pass to webpack.
-o, --output-path <value>              Output location of the file generated by webpack e.g. ./dist/.
-c, --config <value...>                Provide path to a webpack configuration file e.g. ./webpack.config.js.
```
이것들 외에 다른 옵션들도 많지만 기본적으로 중요한 것들을 뽑아보았다. 설명을 보면 알겠지만 각각 아래와 같다.   
* entry : 시작이 되는 자바스크립트 코드   
* mode : development, production인지, 이에 따른 플러그인 사용이 있음.   
* output : 번들파일 경로   
* config : webpack 설정 파일 이름   
webpack config file의 경우 프로젝트에 webpack.config.js란 이름으로 생성해두면 특별한 옵션없이 사용 가능하다. 만약, mode에 따라서나 상황에 따른 설정이 많다면 사용하자!   
entry, mode, output을 설정 파일로 만들면 아래와 같다.
### webpack config file
```
const path=require('path');
module.exports={
  mode:'development',
  entry:{
    main:'./src/app.js'
  },
  output:{
    filename:'bundle.js',
    path:path.resolve("./dist")
  }
}
```
프로젝트를 설정하고 npx webpack을 입력하면 `dist/main.js`가 생기는걸 볼 수 있다. 물론 이는 package.json에 설정하고 사용할 수 있다.
```
"scripts": {
    "build": "npx webpack",   //script를 만들자!
    "test": "echo \"Error: no test specified\" && exit 1"
  }
```
## Loader
웹팩은 모든 파일을 모듈로 취급한다. 자바스크립트 모듈 뿐만 아니라 css, image font 등등 모두 모듈로 보기 떄문에 import를 사용한다면 코드 안으로 가져올 수 있다.    
이런게 가능한 이유는 **로더** 덕분이다. 로더는 타입스크립트를 자바스크립트로 변환해주거나 이미지를 URL로 바꿔주는 등등 여러 역할을 해준다. 자주 쓰이는 로더들도 있지만 그것들을 보기 전에 직접 로더를 만들어보면서 어떻게 동작하는지 알아보자!   
```
//src/loader/myloader.js
module.exports = function myloader(content){
  console.log(content);
  console.log('loader hi');
  return content;
}

/*
import {sum} from './math';
const a = sum(1,2);
console.log(a);
loader hi
export function sum(a,b) {
  return a+b;
}
loader hi
*/

//webpack.config.js
...
module:{
  rules:[
    {
      test:/\.js$/,
      use:[path.resolve('./src/loader/myloader.js)]
    }
  ]
}
```
로더는 content를 인자로 받는 함수이며 이를 통한 또 다른 문자열을 내보낸다. content의 내용을 보니 entry부터 시작해서 import된 것들의 코드 문자열이란 것을 알 수 있다!   
그렇다면 console.log를 alert로 바꿔서 번들링하는 로더를 만들어보자!
```
module.exports = function myloader(content){
  return content.replace('console.log(','alert(');
}
```
`dist/main.js`를 html에 import해보면 alert가 되는 것을 알 수 있다. 만약 테스트로 console.log를 사용한 것들을 출력시키지 않고 싶다면 아래와 같이 만들면 되지 않을까?
```
module.exports = function myloader(content){
  return content.split('\n').filter((code)=>code.indexOf('console.log')===-1).join('\n');
}
```
## 자주 사용하는 Loader
로더의 원리를 확인해보앗으니 자주 사용하는 로더에 대해서 알아보자!
### CSS-Loader
```
green{
  background-color:green;
}
```
앞서 설명 하였듯이 웹팩은 모든 파일을 모듈로써 취급한다.  css-loader는 이름처럼 엔트리를 통해 import된 css파일을 모듈 취급하고자 하기 위해 사용하는 로더이다. 
```
npm i -D css-loader
```
명령어를 통해 css-loader를 설치하고, webpack.config의 module>rules 아래와 같이 입력한 후 웹팩을 실행해보면 번들 파일에 css 내용이 들어간 것을 확인할 수 있다.
```
{
  test:/\.css$/,
  use:["css-loader"]
}
```
### style-loader
```
<div class="green"></div>
```
css-loader는 css를 모듈화 하는 것이지 스타일을 보여주는 것은 아니다. style-loader는 이름처럼 스타일을 html에 적용할 수 있도록 도와주는 로더이다.
```
npm i -D style-loader
```
webpack.config.js의 module>rules에서 각 경우에 대해 여러개 로더를 사용해야할 경우가 있다. 단적인 예로 css의 경우 css-loader, style-loader를 사용해야 HTML에 정상적으로 나타나게 할 수 있다. 이 때 순서가 중요한데, 먼저 적용하고자 하는 로더를 뒤에 입력해야 한다(왜 앞이 아닐까?). 우리는 css를 모듈화 > style적용이니까 아래와 같이 작성해야 한다.
```
{
  test:/\.css$/,
  use:["style-loader","css-loader"]
}
```

### file-loader
```
image[
  background-image : url('a.png')
]
```
file-laoder는 파일을 처리하는 로더이다. css에서 url을 통해 사진을 backgound-image로 설정한 경우 처리를 확인해보자. 우선 우리의 타겟은 png파일이다!
```
npm i -D file-loader

//webpack.config.js module>rules
{
  use:/\.png$/,
  loader:'file-loader',
  options: {
    publicPath: "./dist/", // prefix를 아웃풋 경로로 지정
    name: "[name].[ext]?[hash]", // 파일명 형식
  },
}
```
* 알아봐야 할 것) css-loader가 기본적으로 url의 이미지를 해시처리해서 저장 -> url로 변경함(127.0.0.1~~~) 이거랑 file-loader와 차이는 무엇일지 chk   

## Plugin
웹팩의 또 다른 기능으로 플러그인이 있다. 로더는 엔트리로부터 시작해 코드를 번들링 하고, 웹팩은 번들링된 결과물에 대한 처리를 진행한다. 대표적으로 자바스크립트를 난독화 하는 기능이 있다. 이번에도 로더처럼 직접 만들어보면서 원리를 파악해보자!! 튜토리얼로 보고 있는 블로그 글은 조금 이전 글이라 웹팩 공식 문서를 참고해서 플러그인을 만들어 보았다. [여기](https://webpack.js.org/contribute/writing-a-plugin/#creating-a-plugin)를 참고함!
```
//plugin은 클래스로 만든다!
class FileListPlugin {
  static defaultOptions = {
    outputFile: 'assets.md',
  };

  //플러그인의 옵션은 컨스트럭터를 통해 챙기기
  constructor(options = {}) {

    //기본 옵션의 경우 객체를 하나 만들어두고(이 클래스의 defaultOption 처럼)
    //이 객체와 유저 옵션을 합치는 방식을 사용하자!
    this.options = { ...FileListPlugin.defaultOptions, ...options };
  }

  apply(compiler) {
    const pluginName = FileListPlugin.name;
    //webpack module 인스턴스는 compiler 객체로부터 가져온다.
    //이런 방식으로 webpack module 인스턴스를 가져오면 올바른 버전의 인스턴스를 가져올 수 있다.
    //직접적으로 import 금지! compiler에서 가져오기.
    const { webpack } = compiler;

    // Compilation object gives us reference to some useful constants.
    const { Compilation } = webpack;

    //RawSource는 컴파일 후 결과물인 sources에 관한 클래스 중 하나. 결과물을 만드는데 사용함(?)
    const { RawSource } = webpack.sources;


    //compiler의 hook 중 thisCompilation 훅은 이전 단계에 대해서 단계를 추가하는 훅이다.
    compiler.hooks.thisCompilation.tap(pluginName, (compilation) => {

      //compilations엔 여러가지 훅들이 있는데 그 중 processAssets 이전 단계에 추가하는 것이다.
      compilation.hooks.processAssets.tap(
        {
          name: pluginName,

          // Using one of the later asset processing stages to ensure
          // that all assets were already added to the compilation by other plugins.
          stage: Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE,
        },
        (assets) => {
          // generating content for our Markdown file.
          //processAssets 훅의 콜백함수
          //변수로 assets를 가지는데 이는 로더를 통한 번들 결과물이다. 
          //assets은 객체로 번들 파일의 이름을 key로 가진다. 번들의 결과물은 source함수에 저장되어있음.
        
        /*
          for(const filename of Object.keys(assets)){
            console.log(filename);
            console.log(assets[filename].source());
          }
          */
          
          const content =
            '# In this build:\n\n' +
            Object.keys(assets)
              .map((filename) => `- ${filename}`)
              .join('\n');

          // Adding new asset to the compilation, so it would be automatically
          // generated by the webpack in the output directory.
          //새로운 asset 즉 결과물을 만들기 위해선 compilation객체의 emitAsset 메소드를 이용한다.
          //첫 번째 인자로 파일 이름, 두 번째 인자는 파일에 기록할 source 객체이다.
          compilation.emitAsset('hi.md',new RawSource('this is dino plugin'));
          compilation.emitAsset(
            this.options.outputFile,
            new RawSource(content)
          );
        }
      );
    });
  }
}
module.exports = FileListPlugin;
```
webpack.config.js에 플러그인 설정은 로더와 다르게 객체를 기록해주어야 한다. 로더를 기록하는 module 다음에 설정해주자. 키는 plugins이고 value로 플러그인 리스트를 받는다.
```
plugins: [new FileListPlugin({outputFile:'test.md'})],
```
내가 만든 플러그인은 총 두가지 파일을 추가로 만든다. 코드의 마지막 `emitAccess`를 보면 `hi.md, test.md`를 만들게 되는데, 빌드를 진행하고 dist 경로에 생기는지 확인해보자!
## 자주 사용하는 Plugin
### BannerPlugin
결과물 배너에 정보를 추가하게 해주는 플러그인이다. 
```
const {BannerPlugin} = require('webpack')
new BannerPlugin("is it?")
```
예시로 커밋 해쉬, 빌드 유저 정보, 날짜를 배너에 만들어보자! 
```
//banner.js
const childProcess = require('child_process')
module.exports = function banner(){
  const commit = childProcess.execSync('git rev-parse --short HEAD');
  const user = childProcess.execSync('git config user.name');
  const date = new Date().toLocaleDateString();
  return `commitVersion : ${commit}\nBuild Date : ${date}\nAuthor : ${user}`;
}

//webpack.config.js
plugins: [new BannerPlugin(banner())],
```
이러면 결과물에 위 정보가 주석으로 나타나는 것을 알 수 있다.
### HtmlWebpackPlugin
HtmlWebpackPlugin은 webpack 번들을 제공하는 HTML 파일 생성을 단순화하는 플러그인이다. 매번 컴파일에 파일 명이 해시로 변경되는 경우 유용하게 쓰일 수 있다. html파일의 템플릿을 설정할 수 있고 ejs문법을 통해 데이터를 주입할 수 있다. 자세한 옵션은 [여기](https://github.com/jantimon/html-webpack-plugin#options)를 보자!
```
new HtmlWebpackPlugin({
      template : './src/template.html', //template html 파일
      title: 'dino webpack',          //타이틀 명 
      filename: 'index.html',         //output file name
      inject : 'body',                //번들 Js파일 주입 위치. body or head
})
```